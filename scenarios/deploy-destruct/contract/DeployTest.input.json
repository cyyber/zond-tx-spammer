{
    "language": "Solidity",
    "sources": {
        "DeployTest.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity  ^0.8.22;\n\ncontract DeployTest {\n    event TestSeed(uint seed);\n\n    uint public counter = 1;\n    uint public childIdx = 1;\n    mapping(uint => address) public childAddresses;\n    mapping(address => uint) childAddressIndex;\n\n    function random() private returns (uint) {\n        counter++;\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, counter)));\n    }\n\n    function random2(uint seed, uint id1, uint id2) private pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(seed, id1, id2)));\n    }\n\n    function childCode() public pure returns (bytes memory) {\n        return type(DeployTestChild).creationCode;\n    }\n\n    function create(uint256 amount, bytes memory bytecode) private returns (address) {\n        address addr;\n        assembly {\n            addr := create(amount, add(bytecode, 0x20), mload(bytecode))\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        require(addr != address(0), \"create failed\");\n        return addr;\n    }\n\n    function notify(address addr, bool destroy) public {\n        if(destroy) {\n            uint index = childAddressIndex[addr];\n            if(index > 0) {\n                childAddressIndex[addr] = 0;\n                childIdx--;\n                childAddresses[index] = childAddresses[childIdx];\n                childAddressIndex[childAddresses[index]] = index;\n            }\n        } else {\n            childAddresses[childIdx] = addr;\n            childAddressIndex[addr] = childIdx;\n            childIdx++;\n        }\n    }\n\n    function test(uint seed) public payable {\n        if(seed == 0) {\n            seed = random() % 100000;\n        }\n\n        emit TestSeed(seed);\n\n        uint s1 = random2(seed, 0, 1);\n        if(s1 % 50 < 30) {\n            // deploy new contract\n            bytes memory code = abi.encodePacked(childCode(), abi.encode(s1, 0, address(this)));\n            address addr = create(address(this).balance, code);\n            notify(addr, false);\n        } else if(s1 % 50 < 40) {\n            // destruct child contracts\n            for(uint i = 0; i < 10; i++) {\n                if(childIdx > 1) {\n                    address child = childAddresses[1];\n                    DeployTestChild(child).destroy(random2(seed, 1, i));\n                    notify(child, true);\n                }\n            }\n        } else {\n            // call child contracts\n            uint256 value = address(this).balance;\n            for(uint i = 1; i < childIdx; i++) {\n                address child = childAddresses[i];\n                uint s3 = random2(seed, 0, i);\n                uint256 childValue = value / 100 * (s3 % 80);\n                value -= childValue;\n                DeployTestChild(child).call{value: childValue}(s3);\n            }\n        }\n    }\n\n    function clean(uint count) public {\n        while(count > 0) {\n            if(childIdx > 1) {\n                address child = childAddresses[1];\n                DeployTestChild(child).destroy(5);\n                notify(child, true);\n            }\n            count--;\n        }\n    }\n\n}\n\ncontract DeployTestChild {\n    address public _main;\n    uint public _seed;\n\n    event ChildCreated(uint seed, uint depth);\n    event ChildDestroyed(uint seed, address target);\n    event CatchedRevert(uint seed, uint situation, bytes data);\n\n    constructor(uint seed, uint depth, address main) payable {\n        emit ChildCreated(seed, depth);\n\n        _main = main;\n        _seed = seed;\n        call(depth);\n    }\n\n    function call(uint depth) public payable {\n        uint s2 = random2(_seed, depth, 0);\n        uint256 value = address(this).balance;\n        if(depth < 4 && s2 % 100 < 60) {\n            // create up to 3 nested contracts (chance: 60%)\n            bytes memory initCode = DeployTest(_main).childCode();\n            for(uint i = 0; i < (s2 % 3)+1; i++) {\n                if(gasleft() < 2000000) {\n                    break;\n                }\n\n                uint s3 = random2(_seed, depth, i);\n                bytes memory code = abi.encodePacked(initCode, abi.encode(s3, depth + 1, _main));\n\n                s3 = random2(_seed+1, depth, i);\n                uint256 childValue = value / 100 * (s3 % 80);\n                value -= childValue;\n\n                // CREATE / CREATE2 (chance: 50%)\n                address childAddr;\n                if(s3 % 100 < 50) {\n                    childAddr = create(childValue, code);\n                } else {\n                    childAddr = create2(childValue, i + 1, code);\n                }\n\n                if(childAddr == address(0)) {\n                    break;\n                }\n\n                // selfdestruct on creation (chance: 50%)\n                s3 = random2(_seed+2, depth, i);\n                if(s3 % 100 < 40) {\n                    try DeployTestChild(childAddr).destroy(s3) {\n                    } catch (bytes memory _err) {\n                        emit CatchedRevert(_seed, 1, _err);\n                    }\n                } else {\n                    // notify main contract about this instance, so we can selfdestruct / call it later on\n                    try DeployTest(_main).notify(childAddr, false) {\n                    } catch (bytes memory _err) {\n                        emit CatchedRevert(_seed, 2, _err);\n                    }\n                }\n            }\n        }\n    }\n\n    function random2(uint seed, uint id1, uint id2) private pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(seed, id1, id2)));\n    }\n\n    function create(uint256 amount, bytes memory bytecode) private returns (address) {\n        address addr;\n        assembly {\n            addr := create(amount, add(bytecode, 0x20), mload(bytecode))\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n\n        if(addr == address(0)) {\n            emit CatchedRevert(_seed, 3, abi.encode());\n        }\n        return addr;\n    }\n\n    function create2(uint256 amount, uint salt, bytes memory bytecode) private returns (address) {\n        address addr;\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        if(addr == address(0)) {\n            emit CatchedRevert(_seed, 3, abi.encode());\n        }\n        return addr;\n    }\n\n    function destroy(uint seed) public {\n        address target;\n\n        uint action = seed % 6;\n        // selfdestruct beneficiary (1/6 chance each)\n        if(action == 0) {\n            // target: sender address\n            target = msg.sender;\n        } else if(action == 1) {\n            // target: random new address\n            target = address(bytes20(keccak256(abi.encodePacked(seed))));\n        } else if(action == 2) {\n            // target: origin address\n            target = tx.origin;\n        } else if(action == 3) {\n            // target: self\n            target = address(this);\n        } else if(action == 4) {\n            // target: static address\n            target = address(0x49e0fd3800C117357057534E30c5B5115C673488);\n        } else if(action == 5) {\n            // target: main contract\n            target = _main;\n        }\n\n        emit ChildDestroyed(seed, target);\n\n        selfdestruct(payable(target));\n    }\n\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        },
        "remappings": []
    }
}